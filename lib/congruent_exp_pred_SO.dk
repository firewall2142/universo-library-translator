def congruent_exp_pred_SO :
  sttfa.eps (sttfa.forall nat.nat (p:(sttfa.etap (sttfa.p nat.nat)) => sttfa.forall nat.nat (a:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (prime.prime p) (sttfa.impl (Not.Not (divides.divides p a)) (congruent.congruent (exp.exp a (pred.pred p)) (S.S O.O) p)))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) => a:(sttfa.etap (sttfa.p nat.nat)) => primep:(sttfa.eps (prime.prime p)) => ndiv:(sttfa.eps (Not.Not (divides.divides p a))) => divides_to_congruent.divides_to_congruent (exp.exp a (pred.pred p)) (S.S O.O) p (prime_to_lt_O.prime_to_lt_O p primep) (lt_O_exp.lt_O_exp a (pred.pred p) (match_nat_prop.match_nat_prop (__:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (Not.Not (divides.divides p __)) (lt.lt O.O __)) (_clearme:(sttfa.eps (Not.Not (divides.divides p O.O))) => Not_ind.Not_ind (divides.divides p O.O) (lt.lt O.O O.O) (div0:(sttfa.eps (sttfa.impl (divides.divides p O.O) False.False)) => falsity.falsity (lt.lt O.O O.O) (div0 (quotient.quotient p O.O O.O (rewrite_l.rewrite_l nat.nat O.O (__:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat O.O __) (refl.refl nat.nat O.O) (times.times p O.O) (times_n_O.times_n_O p))))) _clearme) (auto:(sttfa.etap (sttfa.p nat.nat)) => auto':(sttfa.eps (Not.Not (divides.divides p (S.S auto)))) => lt_O_S.lt_O_S auto) a ndiv)) (match_Or_prop.match_Or_prop (divides.divides p (minus.minus (exp.exp a (pred.pred p)) (S.S O.O))) (divides.divides p (fact.fact (pred.pred p))) (divides.divides p (minus.minus (exp.exp a (pred.pred p)) (S.S O.O))) (auto:(sttfa.eps (divides.divides p (minus.minus (exp.exp a (pred.pred p)) (S.S O.O)))) => auto) (Hdiv:(sttfa.eps (divides.divides p (fact.fact (pred.pred p)))) => falsity.falsity (divides.divides p (minus.minus (exp.exp a (pred.pred p)) (S.S O.O))) (absurd.absurd (divides.divides p (fact.fact (pred.pred p))) Hdiv (prime_to_not_divides_fact.prime_to_not_divides_fact p primep (pred.pred p) (le_S_S_to_le.le_S_S_to_le (S.S (pred.pred p)) p (eq_ind_r.eq_ind_r nat.nat p (x:(sttfa.etap (sttfa.p nat.nat)) => le.le (S.S x) (S.S p)) (le_n.le_n (S.S p)) (S.S (pred.pred p)) (S_pred.S_pred p (prime_to_lt_O.prime_to_lt_O p primep))))))) (divides_times_to_divides.divides_times_to_divides p (minus.minus (exp.exp a (pred.pred p)) (S.S O.O)) (fact.fact (pred.pred p)) primep (eq_ind_r.eq_ind_r nat.nat (times.times (fact.fact (pred.pred p)) (minus.minus (exp.exp a (pred.pred p)) (S.S O.O))) (x:(sttfa.etap (sttfa.p nat.nat)) => divides.divides p x) (eq_ind_r.eq_ind_r nat.nat (minus.minus (times.times (fact.fact (pred.pred p)) (exp.exp a (pred.pred p))) (times.times (fact.fact (pred.pred p)) (S.S O.O))) (x:(sttfa.etap (sttfa.p nat.nat)) => divides.divides p x) (eq_ind.eq_ind nat.nat (fact.fact (pred.pred p)) (x_1:(sttfa.etap (sttfa.p nat.nat)) => divides.divides p (minus.minus (times.times (fact.fact (pred.pred p)) (exp.exp a (pred.pred p))) x_1)) (eq_ind_r.eq_ind_r nat.nat (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O))) (x:(sttfa.etap (sttfa.p nat.nat)) => divides.divides p (minus.minus (times.times x (exp.exp a (pred.pred p))) x)) (eq_ind_r.eq_ind_r nat.nat (times.times (exp.exp a (pred.pred p)) (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O)))) (x:(sttfa.etap (sttfa.p nat.nat)) => divides.divides p (minus.minus x (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O))))) (eq_ind_r.eq_ind_r nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (x:(sttfa.etap (sttfa.p nat.nat)) => divides.divides p (minus.minus (times.times (exp.exp a x) (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O)))) (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O))))) (eq_ind_r.eq_ind_r nat.nat (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => times.times a (plus.plus i (S.S O.O)))) (x:(sttfa.etap (sttfa.p nat.nat)) => divides.divides p (minus.minus x (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O))))) (congruent_to_divides.congruent_to_divides (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => times.times a (plus.plus i (S.S O.O)))) (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O))) p (prime_to_lt_O.prime_to_lt_O p primep) (transitive_congruent.transitive_congruent p (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => times.times a (plus.plus i (S.S O.O)))) (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a (plus.plus i (S.S O.O))) p)) (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O))) (congruent_pi.congruent_pi (m:(sttfa.etap (sttfa.p nat.nat)) => times.times a (plus.plus m (S.S O.O))) (minus.minus (S.S (pred.pred p)) (S.S O.O)) p (prime_to_lt_O.prime_to_lt_O p primep)) (eq_ind.eq_ind nat.nat (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O))) (x_1:(sttfa.etap (sttfa.p nat.nat)) => congruent.congruent x_1 (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O))) p) (congruent_n_n.congruent_n_n (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O))) p) (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a (plus.plus i (S.S O.O))) p)) (eq_ind_r.eq_ind_r nat.nat (bigop.bigop nat.nat (S.S (pred.pred p)) (i:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) i) true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => i)) (x:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat x (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a (plus.plus i (S.S O.O))) p))) (eq_ind_r.eq_ind_r nat.nat (bigop.bigop nat.nat (S.S (pred.pred p)) (i:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) i) true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i) p)) (x:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat (bigop.bigop nat.nat (S.S (pred.pred p)) (i:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) i) true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => i)) x) (sym_eq.sym_eq nat.nat (bigop.bigop nat.nat (S.S (pred.pred p)) (i:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) i) true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i) p)) (bigop.bigop nat.nat (S.S (pred.pred p)) (i:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) i) true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => i)) (bigop_iso.bigop_iso (S.S (pred.pred p)) (S.S (pred.pred p)) (__:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) __) true.true) (__:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) __) true.true) (__:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a __) p) (__:(sttfa.etap (sttfa.p nat.nat)) => __) (ex_intro.ex_intro (sttfa.arrow nat.nat nat.nat) (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) => ex.ex (sttfa.arrow nat.nat nat.nat) (k:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) => And.And (And.And (sttfa.forall nat.nat (i:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (lt.lt i (S.S (pred.pred p))) (sttfa.impl (eq.eq bool.bool (andb.andb (leb.leb (S.S O.O) i) true.true) true.true) (eq.eq nat.nat (mod.mod (times.times a i) p) (x i))))) (sub_hk.sub_hk x k (S.S (pred.pred p)) (S.S (pred.pred p)) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a _0) p) (_0:(sttfa.etap (sttfa.p nat.nat)) => _0))) (sub_hk.sub_hk k x (S.S (pred.pred p)) (S.S (pred.pred p)) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => _0) (_0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a _0) p)))) (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i) p) (ex_intro.ex_intro (sttfa.arrow nat.nat nat.nat) (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) => And.And (And.And (sttfa.forall nat.nat (i:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (lt.lt i (S.S (pred.pred p))) (sttfa.impl (eq.eq bool.bool (andb.andb (leb.leb (S.S O.O) i) true.true) true.true) (eq.eq nat.nat (mod.mod (times.times a i) p) (mod.mod (times.times a i) p))))) (sub_hk.sub_hk (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i) p) y (S.S (pred.pred p)) (S.S (pred.pred p)) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a _0) p) (_0:(sttfa.etap (sttfa.p nat.nat)) => _0))) (sub_hk.sub_hk y (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i) p) (S.S (pred.pred p)) (S.S (pred.pred p)) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => _0) (_0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a _0) p))) (invert_permut.invert_permut (pred.pred p) (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i) p)) (conj.conj (And.And (sttfa.forall nat.nat (i:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (lt.lt i (S.S (pred.pred p))) (sttfa.impl (eq.eq bool.bool (andb.andb (leb.leb (S.S O.O) i) true.true) true.true) (eq.eq nat.nat (mod.mod (times.times a i) p) (mod.mod (times.times a i) p))))) (sub_hk.sub_hk (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i) p) (invert_permut.invert_permut (pred.pred p) (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i) p)) (S.S (pred.pred p)) (S.S (pred.pred p)) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a _0) p) (_0:(sttfa.etap (sttfa.p nat.nat)) => _0))) (sub_hk.sub_hk (invert_permut.invert_permut (pred.pred p) (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i) p)) (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i) p) (S.S (pred.pred p)) (S.S (pred.pred p)) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => _0) (_0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a _0) p)) (conj.conj (sttfa.forall nat.nat (x:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (lt.lt x (S.S (pred.pred p))) (sttfa.impl (eq.eq bool.bool (andb.andb (leb.leb (S.S O.O) x) true.true) true.true) (eq.eq nat.nat (mod.mod (times.times a x) p) (mod.mod (times.times a x) p))))) (sub_hk.sub_hk (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i) p) (invert_permut.invert_permut (pred.pred p) (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i) p)) (S.S (pred.pred p)) (S.S (pred.pred p)) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a _0) p) (_0:(sttfa.etap (sttfa.p nat.nat)) => _0)) (i:(sttfa.etap (sttfa.p nat.nat)) => lti:(sttfa.eps (lt.lt i (S.S (pred.pred p)))) => __:(sttfa.eps (eq.eq bool.bool (andb.andb (leb.leb (S.S O.O) i) true.true) true.true)) => refl.refl nat.nat (mod.mod (times.times a i) p)) (i:(sttfa.etap (sttfa.p nat.nat)) => lti:(sttfa.eps (lt.lt i (S.S (pred.pred p)))) => posi:(sttfa.eps (eq.eq bool.bool (andb.andb (leb.leb (S.S O.O) i) true.true) true.true)) => conj.conj (And.And (lt.lt (mod.mod (times.times a i) p) (S.S (pred.pred p))) (eq.eq bool.bool (andb.andb (leb.leb (S.S O.O) (mod.mod (times.times a i) p)) true.true) true.true)) (eq.eq nat.nat (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) (mod.mod (times.times a i) p)) i) (conj.conj (lt.lt (mod.mod (times.times a i) p) (S.S (pred.pred p))) (eq.eq bool.bool (andb.andb (leb.leb (S.S O.O) (mod.mod (times.times a i) p)) true.true) true.true) (eq_ind_r.eq_ind_r nat.nat p (x:(sttfa.etap (sttfa.p nat.nat)) => lt.lt (mod.mod (times.times a i) p) x) (lt_mod_m_m.lt_mod_m_m (times.times a i) p (prime_to_lt_O.prime_to_lt_O p primep)) (S.S (pred.pred p)) (S_pred.S_pred p (prime_to_lt_O.prime_to_lt_O p primep))) (eq_ind_r.eq_ind_r bool.bool true.true (x:(sttfa.etap (sttfa.p bool.bool)) => eq.eq bool.bool (andb.andb x true.true) true.true) (eq_match_bool_type_true.eq_match_bool_type_true bool.bool true.true false.false (y:(sttfa.etap (sttfa.p bool.bool)) => eq.eq bool.bool (andb.andb true.true true.true) y) (refl.refl bool.bool (andb.andb true.true true.true))) (leb.leb (S.S O.O) (mod.mod (times.times a i) p)) (le_to_leb_true.le_to_leb_true (S.S O.O) (mod.mod (times.times a i) p) (match_Or_prop.match_Or_prop (lt.lt O.O (mod.mod (times.times a i) p)) (eq.eq nat.nat O.O (mod.mod (times.times a i) p)) (le.le (S.S O.O) (mod.mod (times.times a i) p)) (auto:(sttfa.eps (lt.lt O.O (mod.mod (times.times a i) p))) => auto) (H:(sttfa.eps (eq.eq nat.nat O.O (mod.mod (times.times a i) p))) => falsity.falsity (le.le (S.S O.O) (mod.mod (times.times a i) p)) (absurd.absurd (divides.divides p (times.times a i)) (mod_O_to_divides.mod_O_to_divides p (times.times a i) (prime_to_lt_O.prime_to_lt_O p primep) (sym_eq.sym_eq nat.nat O.O (mod.mod (times.times a i) p) H)) (not_to_not.not_to_not (divides.divides p (times.times a i)) (divides.divides p a) (Hdiv:(sttfa.eps (divides.divides p (times.times a i))) => match_Or_prop.match_Or_prop (divides.divides p a) (divides.divides p i) (divides.divides p a) (auto:(sttfa.eps (divides.divides p a)) => auto) (divpi:(sttfa.eps (divides.divides p i)) => falsity.falsity (divides.divides p a) (absurd.absurd (lt.lt i (S.S (pred.pred p))) lti (le_to_not_lt.le_to_not_lt (S.S (pred.pred p)) i (eq_ind_r.eq_ind_r nat.nat p (x:(sttfa.etap (sttfa.p nat.nat)) => le.le x i) (divides_to_le.divides_to_le p i (leb_true_to_le.leb_true_to_le (S.S O.O) i (andb_true_l.andb_true_l (leb.leb (S.S O.O) i) true.true posi)) divpi) (S.S (pred.pred p)) (S_pred.S_pred p (prime_to_lt_O.prime_to_lt_O p primep)))))) (divides_times_to_divides.divides_times_to_divides p a i primep Hdiv)) ndiv))) (le_to_or_lt_eq.le_to_or_lt_eq O.O (mod.mod (times.times a i) p) (le_O_n.le_O_n (mod.mod (times.times a i) p))))))) (invert_permut_f.invert_permut_f (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) (pred.pred p) i (le_S_S_to_le.le_S_S_to_le i (pred.pred p) lti) (match_And_prop.match_And_prop (sttfa.forall nat.nat (i1:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (le.le i1 (pred.pred p)) (le.le (mod.mod (times.times a i1) p) (pred.pred p)))) (injn.injn (n:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a n) p) (pred.pred p)) (injn.injn (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) (pred.pred p)) (auto:(sttfa.eps (sttfa.forall nat.nat (i0:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (le.le i0 (pred.pred p)) (le.le (mod.mod (times.times a i0) p) (pred.pred p))))) => auto':(sttfa.eps (injn.injn (n:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a n) p) (pred.pred p))) => auto') (permut_mod.permut_mod p a primep ndiv))))) (match_And_prop.match_And_prop (sttfa.forall nat.nat (i:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (le.le i (pred.pred p)) (le.le (invert_permut.invert_permut (pred.pred p) (n:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a n) p) i) (pred.pred p)))) (injn.injn (invert_permut.invert_permut (pred.pred p) (n:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a n) p)) (pred.pred p)) (sub_hk.sub_hk (invert_permut.invert_permut (pred.pred p) (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i) p)) (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i) p) (S.S (pred.pred p)) (S.S (pred.pred p)) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => andb.andb (leb.leb (S.S O.O) _0) true.true) (_0:(sttfa.etap (sttfa.p nat.nat)) => _0) (_0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a _0) p)) (le_invert_permut:(sttfa.eps (sttfa.forall nat.nat (i:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (le.le i (pred.pred p)) (le.le (invert_permut.invert_permut (pred.pred p) (n:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a n) p) i) (pred.pred p))))) => inj_inv_permut:(sttfa.eps (injn.injn (invert_permut.invert_permut (pred.pred p) (n:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a n) p)) (pred.pred p))) => i:(sttfa.etap (sttfa.p nat.nat)) => lti:(sttfa.eps (lt.lt i (S.S (pred.pred p)))) => posi:(sttfa.eps (eq.eq bool.bool (andb.andb (leb.leb (S.S O.O) i) true.true) true.true)) => conj.conj (And.And (lt.lt (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i) (S.S (pred.pred p))) (eq.eq bool.bool (andb.andb (leb.leb (S.S O.O) (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i)) true.true) true.true)) (eq.eq nat.nat (mod.mod (times.times a (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i)) p) i) (conj.conj (lt.lt (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i) (S.S (pred.pred p))) (eq.eq bool.bool (andb.andb (leb.leb (S.S O.O) (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i)) true.true) true.true) (le_S_S.le_S_S (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i) (pred.pred p) (le_invert_permut i (le_S_S_to_le.le_S_S_to_le i (pred.pred p) lti))) (eq_ind_r.eq_ind_r bool.bool true.true (x:(sttfa.etap (sttfa.p bool.bool)) => eq.eq bool.bool (andb.andb x true.true) true.true) (eq_match_bool_type_true.eq_match_bool_type_true bool.bool true.true false.false (y:(sttfa.etap (sttfa.p bool.bool)) => eq.eq bool.bool (andb.andb true.true true.true) y) (refl.refl bool.bool (andb.andb true.true true.true))) (leb.leb (S.S O.O) (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i)) (le_to_leb_true.le_to_leb_true (S.S O.O) (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i) (match_Or_prop.match_Or_prop (lt.lt O.O (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i)) (eq.eq nat.nat O.O (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i)) (le.le (S.S O.O) (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i)) (auto:(sttfa.eps (lt.lt O.O (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i))) => auto) (H:(sttfa.eps (eq.eq nat.nat O.O (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i))) => falsity.falsity (le.le (S.S O.O) (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i)) (eq_ind_r.eq_ind_r nat.nat O.O (x:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (eq.eq nat.nat x (mod.mod (times.times a (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i)) p)) False.False) (eq_ind_r.eq_ind_r nat.nat i (x:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (eq.eq nat.nat O.O x) False.False) (eq0i:(sttfa.eps (eq.eq nat.nat O.O i)) => eq_ind.eq_ind nat.nat O.O (x_1:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (eq.eq bool.bool (andb.andb (leb.leb (S.S O.O) x_1) true.true) true.true) False.False) (sym_eq_leb.sym_eq_leb (S.S O.O) (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) => sttfa.impl (eq.eq bool.bool (andb.andb (y O.O) true.true) true.true) False.False) (sym_eq_filter_nat_type_S.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat bool.bool) leb_body.leb_body O.O (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) => sttfa.impl (eq.eq bool.bool (andb.andb (y O.O) true.true) true.true) False.False) (sym_eq_leb_body_S.sym_eq_leb_body_S O.O (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) => sttfa.impl (eq.eq bool.bool (andb.andb (y O.O) true.true) true.true) False.False) (sym_eq_match_nat_type_O.sym_eq_match_nat_type_O bool.bool false.false (q:(sttfa.etap (sttfa.p nat.nat)) => leb.leb O.O q) (y:(sttfa.etap (sttfa.p bool.bool)) => sttfa.impl (eq.eq bool.bool (andb.andb y true.true) true.true) False.False) (sym_eq_match_bool_type_false.sym_eq_match_bool_type_false bool.bool true.true false.false (y:(sttfa.etap (sttfa.p bool.bool)) => sttfa.impl (eq.eq bool.bool y true.true) False.False) (H0:(sttfa.eps (eq.eq bool.bool false.false true.true)) => eq_match_bool_type_true.eq_match_bool_type_true sttfa.bool (sttfa.forall sttfa.bool (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) (sttfa.forall sttfa.bool (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) (y:(sttfa.etap (sttfa.p sttfa.bool)) => y) (eq_match_bool_type_false.eq_match_bool_type_false sttfa.bool (match_bool_type.match_bool_type sttfa.bool (sttfa.forall sttfa.bool (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) (sttfa.forall sttfa.bool (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) true.true) (match_bool_type.match_bool_type sttfa.bool (sttfa.forall sttfa.bool (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) (sttfa.forall sttfa.bool (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) true.true) (y:(sttfa.etap (sttfa.p sttfa.bool)) => y) (bool_discr.bool_discr false.false true.true H0)) False.False)))))) i eq0i posi) (mod.mod (times.times a (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i)) p) (f_invert_permut.f_invert_permut (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) (pred.pred p) i (le_S_S_to_le.le_S_S_to_le i (pred.pred p) lti) (permut_mod.permut_mod p a primep ndiv))) (mod.mod (times.times a O.O) p) (eq_ind.eq_ind nat.nat O.O (x_1:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat (mod.mod x_1 p) O.O) (rewrite_r.rewrite_r nat.nat O.O (__:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat __ O.O) (refl.refl nat.nat O.O) (mod.mod O.O p) (mod_O_n.mod_O_n p)) (times.times a O.O) (times_n_O.times_n_O a)) (eq_f.eq_f nat.nat nat.nat (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) O.O (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i) (rewrite_l.rewrite_l nat.nat O.O (__:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat O.O __) (refl.refl nat.nat O.O) (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i) H)))) (le_to_or_lt_eq.le_to_or_lt_eq O.O (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i) (le_O_n.le_O_n (invert_permut.invert_permut (pred.pred p) (i0:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a i0) p) i))))))) (f_invert_permut.f_invert_permut (__:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a __) p) (pred.pred p) i (le_S_S_to_le.le_S_S_to_le i (pred.pred p) lti) (permut_mod.permut_mod p a primep ndiv))) (permut_invert_permut.permut_invert_permut (n:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a n) p) (pred.pred p) (permut_mod.permut_mod p a primep ndiv)))))))) (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a (plus.plus i (S.S O.O))) p)) (bigop_I_gen.bigop_I_gen (S.S O.O) (S.S (pred.pred p)) (__:(sttfa.etap (sttfa.p nat.nat)) => true.true) (__:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a __) p) (lt_O_S.lt_O_S (pred.pred p)))) (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O))) (bigop_I_gen.bigop_I_gen (S.S O.O) (S.S (pred.pred p)) (__:(sttfa.etap (sttfa.p nat.nat)) => true.true) (__:(sttfa.etap (sttfa.p nat.nat)) => __) (lt_O_S.lt_O_S (pred.pred p))))))) (times.times (exp.exp a (minus.minus (S.S (pred.pred p)) (S.S O.O))) (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O)))) (exp_pi_bc.exp_pi_bc a (S.S O.O) (S.S (pred.pred p)) (__:(sttfa.etap (sttfa.p nat.nat)) => __))) (pred.pred p) (rewrite_r.rewrite_r nat.nat (minus.minus (pred.pred p) O.O) (__:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat (pred.pred p) __) (rewrite_l.rewrite_l nat.nat (pred.pred p) (__:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat (pred.pred p) __) (refl.refl nat.nat (pred.pred p)) (minus.minus (pred.pred p) O.O) (minus_n_O.minus_n_O (pred.pred p))) (minus.minus (S.S (pred.pred p)) (S.S O.O)) (minus_S_S.minus_S_S (pred.pred p) O.O))) (times.times (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O))) (exp.exp a (pred.pred p))) (commutative_times.commutative_times (bigop.bigop nat.nat (minus.minus (S.S (pred.pred p)) (S.S O.O)) (i:(sttfa.etap (sttfa.p nat.nat)) => true.true) (S.S O.O) times.times (i:(sttfa.etap (sttfa.p nat.nat)) => plus.plus i (S.S O.O))) (exp.exp a (pred.pred p)))) (fact.fact (pred.pred p)) (eq_fact_pi_p.eq_fact_pi_p (pred.pred p))) (times.times (fact.fact (pred.pred p)) (S.S O.O)) (times_n_1.times_n_1 (fact.fact (pred.pred p)))) (times.times (fact.fact (pred.pred p)) (minus.minus (exp.exp a (pred.pred p)) (S.S O.O))) (distributive_times_minus.distributive_times_minus (fact.fact (pred.pred p)) (exp.exp a (pred.pred p)) (S.S O.O))) (times.times (minus.minus (exp.exp a (pred.pred p)) (S.S O.O)) (fact.fact (pred.pred p))) (commutative_times.commutative_times (minus.minus (exp.exp a (pred.pred p)) (S.S O.O)) (fact.fact (pred.pred p)))))).

