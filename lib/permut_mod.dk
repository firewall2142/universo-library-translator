def permut_mod :
  sttfa.eps (sttfa.forall nat.nat (p:(sttfa.etap (sttfa.p nat.nat)) => sttfa.forall nat.nat (a:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (prime.prime p) (sttfa.impl (Not.Not (divides.divides p a)) (permut.permut (n:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a n) p) (pred.pred p))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) => a:(sttfa.etap (sttfa.p nat.nat)) => primep:(sttfa.eps (prime.prime p)) => ndiv:(sttfa.eps (Not.Not (divides.divides p a))) => conj.conj (sttfa.forall nat.nat (x:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (le.le x (pred.pred p)) (le.le (mod.mod (times.times a x) p) (pred.pred p)))) (injn.injn (n:(sttfa.etap (sttfa.p nat.nat)) => mod.mod (times.times a n) p) (pred.pred p)) (i:(sttfa.etap (sttfa.p nat.nat)) => lei:(sttfa.eps (le.le i (pred.pred p))) => le_S_S_to_le.le_S_S_to_le (mod.mod (times.times a i) p) (pred.pred p) (transitive_le.transitive_le (S.S (mod.mod (times.times a i) p)) p (S.S (pred.pred p)) (lt_mod_m_m.lt_mod_m_m (times.times a i) p (prime_to_lt_O.prime_to_lt_O p primep)) (eq_ind_r.eq_ind_r nat.nat p (x:(sttfa.etap (sttfa.p nat.nat)) => le.le p x) (le_n.le_n p) (S.S (pred.pred p)) (S_pred.S_pred p (prime_to_lt_O.prime_to_lt_O p primep))))) (i:(sttfa.etap (sttfa.p nat.nat)) => j:(sttfa.etap (sttfa.p nat.nat)) => lei:(sttfa.eps (le.le i (pred.pred p))) => lej:(sttfa.eps (le.le j (pred.pred p))) => H:(sttfa.eps (eq.eq nat.nat (mod.mod (times.times a i) p) (mod.mod (times.times a j) p))) => match_Or_prop.match_Or_prop (lt.lt i j) (Not.Not (lt.lt i j)) (eq.eq nat.nat i j) (ltij:(sttfa.eps (lt.lt i j)) => falsity.falsity (eq.eq nat.nat i j) (absurd.absurd (lt.lt (minus.minus j i) p) (eq_ind.eq_ind nat.nat (S.S (pred.pred p)) (x_1:(sttfa.etap (sttfa.p nat.nat)) => lt.lt (minus.minus j i) x_1) (le_S_S.le_S_S (minus.minus j i) (pred.pred p) (le_plus_to_minus.le_plus_to_minus j i (pred.pred p) (transitive_le.transitive_le j (pred.pred p) (plus.plus (pred.pred p) i) lej (le_plus_n_r.le_plus_n_r i (pred.pred p))))) p (S_pred.S_pred p (prime_to_lt_O.prime_to_lt_O p primep))) (le_to_not_lt.le_to_not_lt p (minus.minus j i) (divides_to_le.divides_to_le p (minus.minus j i) (lt_plus_to_minus_r.lt_plus_to_minus_r O.O i j (sym_eq_plus.sym_eq_plus O.O (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) => le.le (S.S (y i)) j) (sym_eq_filter_nat_type_O.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) plus_body.plus_body (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) => le.le (S.S (y i)) j) (sym_eq_plus_body_O.sym_eq_plus_body_O (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) => le.le (S.S (y i)) j) ltij)))) (match_Or_prop.match_Or_prop (divides.divides p a) (divides.divides p (minus.minus j i)) (divides.divides p (minus.minus j i)) (Hdiv:(sttfa.eps (divides.divides p a)) => falsity.falsity (divides.divides p (minus.minus j i)) (absurd.absurd (divides.divides p a) Hdiv ndiv)) (auto:(sttfa.eps (divides.divides p (minus.minus j i))) => auto) (divides_times_to_divides.divides_times_to_divides p a (minus.minus j i) primep (eq_ind_r.eq_ind_r nat.nat (minus.minus (times.times a j) (times.times a i)) (x:(sttfa.etap (sttfa.p nat.nat)) => divides.divides p x) (eq_mod_to_divides.eq_mod_to_divides (times.times a j) (times.times a i) p (prime_to_lt_O.prime_to_lt_O p primep) (rewrite_l.rewrite_l nat.nat (mod.mod (times.times a i) p) (__:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat __ (mod.mod (times.times a i) p)) (refl.refl nat.nat (mod.mod (times.times a i) p)) (mod.mod (times.times a j) p) H)) (times.times a (minus.minus j i)) (distributive_times_minus.distributive_times_minus a j i)))))))) (Hij:(sttfa.eps (Not.Not (lt.lt i j))) => match_Or_prop.match_Or_prop (lt.lt j i) (eq.eq nat.nat j i) (eq.eq nat.nat i j) (Hij0:(sttfa.eps (lt.lt j i)) => falsity.falsity (eq.eq nat.nat i j) (absurd.absurd (lt.lt (minus.minus i j) p) (eq_ind.eq_ind nat.nat (S.S (pred.pred p)) (x_1:(sttfa.etap (sttfa.p nat.nat)) => lt.lt (minus.minus i j) x_1) (le_S_S.le_S_S (minus.minus i j) (pred.pred p) (le_plus_to_minus.le_plus_to_minus i j (pred.pred p) (transitive_le.transitive_le i (pred.pred p) (plus.plus (pred.pred p) j) lei (le_plus_n_r.le_plus_n_r j (pred.pred p))))) p (S_pred.S_pred p (prime_to_lt_O.prime_to_lt_O p primep))) (le_to_not_lt.le_to_not_lt p (minus.minus i j) (divides_to_le.divides_to_le p (minus.minus i j) (lt_plus_to_minus_r.lt_plus_to_minus_r O.O j i (sym_eq_plus.sym_eq_plus O.O (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) => le.le (S.S (y j)) i) (sym_eq_filter_nat_type_O.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) plus_body.plus_body (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) => le.le (S.S (y j)) i) (sym_eq_plus_body_O.sym_eq_plus_body_O (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) => le.le (S.S (y j)) i) Hij0)))) (match_Or_prop.match_Or_prop (divides.divides p a) (divides.divides p (minus.minus i j)) (divides.divides p (minus.minus i j)) (Hdiv:(sttfa.eps (divides.divides p a)) => falsity.falsity (divides.divides p (minus.minus i j)) (absurd.absurd (divides.divides p a) Hdiv ndiv)) (auto:(sttfa.eps (divides.divides p (minus.minus i j))) => auto) (divides_times_to_divides.divides_times_to_divides p a (minus.minus i j) primep (eq_ind_r.eq_ind_r nat.nat (minus.minus (times.times a i) (times.times a j)) (x:(sttfa.etap (sttfa.p nat.nat)) => divides.divides p x) (eq_mod_to_divides.eq_mod_to_divides (times.times a i) (times.times a j) p (prime_to_lt_O.prime_to_lt_O p primep) (rewrite_l.rewrite_l nat.nat (mod.mod (times.times a i) p) (__:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat (mod.mod (times.times a i) p) __) (refl.refl nat.nat (mod.mod (times.times a i) p)) (mod.mod (times.times a j) p) H)) (times.times a (minus.minus i j)) (distributive_times_minus.distributive_times_minus a i j)))))))) (Hij0:(sttfa.eps (eq.eq nat.nat j i)) => rewrite_r.rewrite_r nat.nat i (__:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat i __) (refl.refl nat.nat i) j Hij0) (le_to_or_lt_eq.le_to_or_lt_eq j i (not_lt_to_le.not_lt_to_le i j Hij))) (decidable_lt.decidable_lt i j)).

