def dividesb_false_to_not_divides :
  sttfa.eps (sttfa.forall nat.nat (n:(sttfa.etap (sttfa.p nat.nat)) => sttfa.forall nat.nat (m:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (eq.eq bool.bool (dividesb.dividesb n m) false.false) (Not.Not (divides.divides n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) => m:(sttfa.etap (sttfa.p nat.nat)) => match_Or_prop.match_Or_prop (lt.lt O.O n) (eq.eq nat.nat O.O n) (sttfa.impl (eq.eq bool.bool (dividesb.dividesb n m) false.false) (Not.Not (divides.divides n m))) (posn:(sttfa.eps (lt.lt O.O n)) => ndivbnm:(sttfa.eps (eq.eq bool.bool (dividesb.dividesb n m) false.false)) => not_to_not.not_to_not (divides.divides n m) (eq.eq nat.nat (mod.mod m n) O.O) (divides_to_mod_O.divides_to_mod_O n m posn) (eqb_false_to_not_eq.eqb_false_to_not_eq (mod.mod m n) O.O ndivbnm)) (eqnO:(sttfa.eps (eq.eq nat.nat O.O n)) => eq_ind.eq_ind nat.nat O.O (x_1:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (eq.eq bool.bool (dividesb.dividesb x_1 m) false.false) (Not.Not (divides.divides x_1 m))) (sym_eq_match_nat_type_O.sym_eq_match_nat_type_O nat.nat m (p:(sttfa.etap (sttfa.p nat.nat)) => mod_aux.mod_aux m m p) (y:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (eq.eq bool.bool (eqb.eqb y O.O) false.false) (Not.Not (divides.divides O.O m))) (nat_case.nat_case m (__:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (eq.eq bool.bool (eqb.eqb __ O.O) false.false) (Not.Not (divides.divides O.O __))) (sym_eq_eqb.sym_eq_eqb O.O (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) => sttfa.impl (eq.eq nat.nat m O.O) (sttfa.impl (eq.eq bool.bool (y O.O) false.false) (Not.Not (divides.divides O.O O.O)))) (sym_eq_filter_nat_type_O.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat bool.bool) eqb_body.eqb_body (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) => sttfa.impl (eq.eq nat.nat m O.O) (sttfa.impl (eq.eq bool.bool (y O.O) false.false) (Not.Not (divides.divides O.O O.O)))) (sym_eq_eqb_body_O.sym_eq_eqb_body_O (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) => sttfa.impl (eq.eq nat.nat m O.O) (sttfa.impl (eq.eq bool.bool (y O.O) false.false) (Not.Not (divides.divides O.O O.O)))) (sym_eq_match_nat_type_O.sym_eq_match_nat_type_O bool.bool true.true (q:(sttfa.etap (sttfa.p nat.nat)) => false.false) (y:(sttfa.etap (sttfa.p bool.bool)) => sttfa.impl (eq.eq nat.nat m O.O) (sttfa.impl (eq.eq bool.bool y false.false) (Not.Not (divides.divides O.O O.O)))) (auto:(sttfa.eps (eq.eq nat.nat m O.O)) => auto':(sttfa.eps (eq.eq bool.bool true.true false.false)) => not_to_not.not_to_not (divides.divides O.O O.O) (eq.eq bool.bool true.true false.false) (auto'':(sttfa.eps (divides.divides O.O O.O)) => rewrite_l.rewrite_l bool.bool true.true (__:(sttfa.etap (sttfa.p bool.bool)) => eq.eq bool.bool true.true __) (refl.refl bool.bool true.true) false.false auto') not_eq_true_false.not_eq_true_false))))) (a:(sttfa.etap (sttfa.p nat.nat)) => __:(sttfa.eps (eq.eq nat.nat m (S.S a))) => _0:(sttfa.eps (eq.eq bool.bool (eqb.eqb (S.S a) O.O) false.false)) => nmk.nmk (divides.divides O.O (S.S a)) (_clearme:(sttfa.eps (divides.divides O.O (S.S a))) => match_divides_prop.match_divides_prop O.O (S.S a) False.False (q:(sttfa.etap (sttfa.p nat.nat)) => auto:(sttfa.eps (eq.eq nat.nat (S.S a) (times.times O.O q))) => absurd.absurd (eq.eq nat.nat O.O (S.S a)) (rewrite_r.rewrite_r nat.nat n (__1:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat __1 (S.S a)) (rewrite_l.rewrite_l nat.nat (S.S a) (__1:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat __1 (S.S a)) (refl.refl nat.nat (S.S a)) n (rewrite_l.rewrite_l nat.nat O.O (__1:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat (S.S a) __1) (rewrite_r.rewrite_r nat.nat (times.times q O.O) (__1:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat (S.S a) __1) (rewrite_l.rewrite_l nat.nat (times.times O.O q) (__1:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat (S.S a) __1) auto (times.times q O.O) (commutative_times.commutative_times O.O q)) O.O (times_n_O.times_n_O q)) n eqnO)) O.O eqnO) (not_eq_O_S.not_eq_O_S a)) _clearme)))) n eqnO) (le_to_or_lt_eq.le_to_or_lt_eq O.O n (le_O_n.le_O_n n)).

