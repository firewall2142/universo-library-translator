def divides_to_congruent :
  sttfa.eps (sttfa.forall nat.nat (n:(sttfa.etap (sttfa.p nat.nat)) => sttfa.forall nat.nat (m:(sttfa.etap (sttfa.p nat.nat)) => sttfa.forall nat.nat (p:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (lt.lt O.O p) (sttfa.impl (le.le m n) (sttfa.impl (divides.divides p (minus.minus n m)) (congruent.congruent n m p)))))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) => m:(sttfa.etap (sttfa.p nat.nat)) => p:(sttfa.etap (sttfa.p nat.nat)) => posp:(sttfa.eps (lt.lt O.O p)) => lemn:(sttfa.eps (le.le m n)) => _clearme:(sttfa.eps (divides.divides p (minus.minus n m))) => match_divides_prop.match_divides_prop p (minus.minus n m) (congruent.congruent n m p) (q:(sttfa.etap (sttfa.p nat.nat)) => Hdiv:(sttfa.eps (eq.eq nat.nat (minus.minus n m) (times.times p q))) => eq_times_plus_to_congruent.eq_times_plus_to_congruent n m p q posp (eq_ind_r.eq_ind_r nat.nat (plus.plus m (times.times q p)) (x:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat n x) (minus_to_plus.minus_to_plus n m (times.times q p) lemn (rewrite_r.rewrite_r nat.nat (times.times p q) (__:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat __ (times.times q p)) (rewrite_r.rewrite_r nat.nat (times.times p q) (__:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat (times.times p q) __) (refl.refl nat.nat (times.times p q)) (times.times q p) (commutative_times.commutative_times q p)) (minus.minus n m) Hdiv)) (plus.plus (times.times q p) m) (commutative_plus.commutative_plus (times.times q p) m))) _clearme.

