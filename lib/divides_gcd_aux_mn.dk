def divides_gcd_aux_mn :
  sttfa.eps (sttfa.forall nat.nat (p:(sttfa.etap (sttfa.p nat.nat)) => sttfa.forall nat.nat (m:(sttfa.etap (sttfa.p nat.nat)) => sttfa.forall nat.nat (n:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (lt.lt O.O n) (sttfa.impl (le.le n m) (sttfa.impl (le.le n p) (And.And (divides.divides (gcd_aux.gcd_aux p m n) m) (divides.divides (gcd_aux.gcd_aux p m n) n))))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) => nat_ind.nat_ind (_x_365:(sttfa.etap (sttfa.p nat.nat)) => sttfa.forall nat.nat (m:(sttfa.etap (sttfa.p nat.nat)) => sttfa.forall nat.nat (n:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (lt.lt O.O n) (sttfa.impl (le.le n m) (sttfa.impl (le.le n _x_365) (And.And (divides.divides (gcd_aux.gcd_aux _x_365 m n) m) (divides.divides (gcd_aux.gcd_aux _x_365 m n) n))))))) (m:(sttfa.etap (sttfa.p nat.nat)) => n:(sttfa.etap (sttfa.p nat.nat)) => posn:(sttfa.eps (lt.lt O.O n)) => lenm:(sttfa.eps (le.le n m)) => lenO:(sttfa.eps (le.le n O.O)) => falsity.falsity (And.And (divides.divides (gcd_aux.gcd_aux O.O m n) m) (divides.divides (gcd_aux.gcd_aux O.O m n) n)) (absurd.absurd (lt.lt O.O n) posn (le_to_not_lt.le_to_not_lt n O.O lenO))) (q:(sttfa.etap (sttfa.p nat.nat)) => Hind:(sttfa.eps (sttfa.forall nat.nat (m:(sttfa.etap (sttfa.p nat.nat)) => sttfa.forall nat.nat (n:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (lt.lt O.O n) (sttfa.impl (le.le n m) (sttfa.impl (le.le n q) (And.And (divides.divides (gcd_aux.gcd_aux q m n) m) (divides.divides (gcd_aux.gcd_aux q m n) n)))))))) => m:(sttfa.etap (sttfa.p nat.nat)) => n:(sttfa.etap (sttfa.p nat.nat)) => posn:(sttfa.eps (lt.lt O.O n)) => lenm:(sttfa.eps (le.le n m)) => lenS:(sttfa.eps (le.le n (S.S q))) => match_Or_prop.match_Or_prop (divides.divides n m) (Not.Not (divides.divides n m)) (And.And (divides.divides (gcd_aux.gcd_aux (S.S q) m n) m) (divides.divides (gcd_aux.gcd_aux (S.S q) m n) n)) (divnm:(sttfa.eps (divides.divides n m)) => eq_ind_r.eq_ind_r nat.nat n (x:(sttfa.etap (sttfa.p nat.nat)) => And.And (divides.divides x m) (divides.divides x n)) (conj.conj (divides.divides n m) (divides.divides n n) divnm (divides_n_n.divides_n_n n)) (gcd_aux.gcd_aux (S.S q) m n) (divides_to_gcd_aux.divides_to_gcd_aux (S.S q) m n (lt_O_S.lt_O_S q) posn divnm)) (ndivnm:(sttfa.eps (Not.Not (divides.divides n m))) => eq_ind_r.eq_ind_r nat.nat (gcd_aux.gcd_aux q n (mod.mod m n)) (x:(sttfa.etap (sttfa.p nat.nat)) => And.And (divides.divides x m) (divides.divides x n)) (match_And_prop.match_And_prop (divides.divides (gcd_aux.gcd_aux q n (mod.mod m n)) n) (divides.divides (gcd_aux.gcd_aux q n (mod.mod m n)) (mod.mod m n)) (And.And (divides.divides (gcd_aux.gcd_aux q n (mod.mod m n)) m) (divides.divides (gcd_aux.gcd_aux q n (mod.mod m n)) n)) (H:(sttfa.eps (divides.divides (gcd_aux.gcd_aux q n (mod.mod m n)) n)) => H1:(sttfa.eps (divides.divides (gcd_aux.gcd_aux q n (mod.mod m n)) (mod.mod m n))) => conj.conj (divides.divides (gcd_aux.gcd_aux q n (mod.mod m n)) m) (divides.divides (gcd_aux.gcd_aux q n (mod.mod m n)) n) (divides_mod_to_divides.divides_mod_to_divides (gcd_aux.gcd_aux q n (mod.mod m n)) m n posn H1 H) H) (Hind n (mod.mod m n) (match_Or_prop.match_Or_prop (lt.lt O.O (mod.mod m n)) (eq.eq nat.nat O.O (mod.mod m n)) (lt.lt O.O (mod.mod m n)) (auto:(sttfa.eps (lt.lt O.O (mod.mod m n))) => auto) (modO:(sttfa.eps (eq.eq nat.nat O.O (mod.mod m n))) => falsity.falsity (lt.lt O.O (mod.mod m n)) (absurd.absurd (divides.divides n m) (mod_O_to_divides.mod_O_to_divides n m posn (rewrite_l.rewrite_l nat.nat O.O (__:(sttfa.etap (sttfa.p nat.nat)) => eq.eq nat.nat __ O.O) (refl.refl nat.nat O.O) (mod.mod m n) modO)) ndivnm)) (le_to_or_lt_eq.le_to_or_lt_eq O.O (mod.mod m n) (le_O_n.le_O_n (mod.mod m n)))) (lt_to_le.lt_to_le (mod.mod m n) n (lt_mod_m_m.lt_mod_m_m m n posn)) (le_S_S_to_le.le_S_S_to_le (mod.mod m n) q (transitive_le.transitive_le (S.S (mod.mod m n)) n (S.S q) (lt_mod_m_m.lt_mod_m_m m n posn) lenS)))) (gcd_aux.gcd_aux (S.S q) m n) (not_divides_to_gcd_aux.not_divides_to_gcd_aux q m n posn ndivnm)) (decidable_divides.decidable_divides n m)) p.

